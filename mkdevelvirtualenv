#!/usr/bin/env bash
#
# Wraps virtualenvwrapper's mkvirtualenv and provides a very easy way of
# creating development virtual environments for your python projects.
#

die() {
    echo "Error:" "$@" >&2
    exit 1
}

show_help() {
    cat <<EOF
usage: $script_name [-h] [-f] [-a PROJECT] [-n NAME] [-p PYTHON] [-v VIRTUALENV]

Wraps virtualenvwrapper's mkvirtualenv and provides a very easy way of
creating development virtual environments for your python projects.

If you cloned some of required packages into the project root and want to use
the cloned versions instead of installing them via pip into the virtual
environment, just list these package names in local-requirements.txt - they
won't be installed, but their paths will be added to PYTHONPATH of the created
virtual environment.

optional arguments:
  -h, --help            show this help message and exit
  -f, --force           replace existing virtual environment if exists
  -a PROJECT, --project PROJECT
                        path to the project (default is current directory)
  -n NAME, --name NAME
                        virtual environment name (default is name of
                        project's directory)
  -p PYTHON, --python PYTHON
                        python interpreter to use (default is python)
  -v VIRTUALENV, --virtualenv VIRTUALENV
                        virtualenv to use (default is virtualenv)
  -s, --system-site-packages
                        give the virtual environment access to the global
                        site-packages
  -i, --index-url URL   base URL of Python Package Index
EOF
}

check_option() {
    [ -n "$2" ] || die "Invalid option $1 value."
}

parse_args() {
    eval set -- "$@"

    while [ $# -gt 0 ]; do
        case "$1" in
            -h|--help) show_help; exit 0;;
            -f|--force) force=1;;
            -a|--project) check_option $1 $2; project_path="$2"; shift;;
            -n|--name) check_option $1 $2; project_name="$2"; shift;;
            -p|--python) check_option $1 $2; python="$2"; shift;;
            -v|--virtualenv) check_option $1 $2; virtualenv="$2"; shift;;
            -s|--system-site-packages) virtualenv_options="$virtualenv_options --system-site-packages"; shift;;
            -i|--index-url) check_option $1 $2; pip_options+=("-i" "$2"); shift;;
            --) shift; break;;
            (-*) die "Unrecognized option: $1.";;
            (*) break;;
        esac
        shift
    done

    [ $# -eq 0 ] || die "Invalid parameter: $1."

    project_path="$(cd "$project_path" && pwd)"
    [ "$project_path" != "/" -a "$project_path" != "//" ] || \
        die "Invalid project path: $project_path."

    if [ -z "$project_name" ]; then
        project_name="$(basename "$project_path")"
    else
        [[ "$project_name" != */* ]] || die "Invalid virtual environment name: $project_name."
    fi

    if [[ "$python" != */* ]]; then
        local python_path
        python_path="$(which "$python")" || die "Unable to find '$python' executable."
        python="$python_path"
    fi
}

cleanup() {
    [ -z "$temp_dir" ] || rm -rf "$temp_dir"
}

create_virtualenv() {
    local env_name
    local existing_envs
    local virtualenvwrapper

    if ! type -t mkvirtualenv > /dev/null; then
        if [ "$(uname)" = Darwin ]; then
            virtualenvwrapper="$(which virtualenvwrapper.sh)" || die "Unable to find virtualenvwrapper.sh."
        elif [ -e /etc/bash_completion.d/virtualenvwrapper ]; then
            virtualenvwrapper=/etc/bash_completion.d/virtualenvwrapper
        else
            die "Unable to find virtualenvwrapper."
        fi

        set +eu;
            . "$virtualenvwrapper" || die "Failed to activate virtualenvwrapper.";
        set -eu
    fi

    set +eu;
        existing_envs="$(lsvirtualenv)" || \
            die "Unable to get a list of existing virtual environments.";
    set -eu

    while read env_name; do
        [ "$env_name" = "$project_name" ] || continue
        [ "$force" -ne 0 ] || die "Virtual environment '$project_name' already exists."

        set +eu
            rmvirtualenv "$project_name" || die "Failed to remove virtual environment '$project_name'."
        set -eu
    done <<<"$existing_envs"

    set +eu
        VIRTUALENVWRAPPER_VIRTUALENV="$virtualenv" VIRTUALENVWRAPPER_VIRTUALENV_ARGS="$virtualenv_options" \
            mkvirtualenv -p "$python" -a "$project_path" "$project_name" && \
                workon "$project_name" || die "Failed to create the virtual environment."
    set -eu

    configure_virtualenv
}

configure_virtualenv() {
    local sed
    local package_name
    local package_path
    local local_packages
    local requirements_file

    [ "$(uname)" = Darwin ] && sed='sed -E' || sed='sed -r'

    set +u
        pip install "${pip_options[@]}" -U pip
    set -u

    for requirements_file in "requirements.txt" "test-requirements.txt"; do
        [ ! -e "$project_path/$requirements_file" ] || \
            cp "$project_path/$requirements_file" "$temp_dir/project-$requirements_file"
    done

    if [ -e "$project_path/local-requirements.txt" ]; then
        local_packages="$(< "$project_path/local-requirements.txt")"

        for package_name in $local_packages; do
            package_path="$project_path/$package_name"

            [ -d "$package_path" ] || \
                die "Unable to find local package '$package_name' which is listed in $project_path/local-requirements.txt."

            if [ -d "$package_path/src" ]; then
                add2virtualenv "$package_path/src"
            else
                add2virtualenv "$package_path"
            fi

            [ ! -e "$package_path/requirements.txt" ] || \
                cp "$package_path/requirements.txt" "$temp_dir/package-$package_name-requirements.txt"
        done

        for package_name in $local_packages; do
            shopt -s nullglob
            for requirements_file in "$temp_dir/"*requirements.txt; do
                $sed -i.bak "/^\\s*$package_name([<=>]|\\s*\$)/d" "$requirements_file"
            done
            shopt -u nullglob
        done
    fi

    shopt -s nullglob
    # The project may override requirements, so install its requirements at the very end
    for requirements_file in "$temp_dir/"package-*-requirements.txt "$temp_dir/"project-*requirements.txt; do
        set +u
            pip install "${pip_options[@]}" -r "$requirements_file"
        set -u
    done
    shopt -u nullglob

    add2virtualenv "$project_path"
}


set -eu
script_name="$0"

force=0
project_path="$PWD"
project_name=""
python="python"
virtualenv="virtualenv"
virtualenv_options=""
pip_options=()

parse_args "$(getopt -n "$0" -o hfa:n:p:v:si: -l help,force,project:,name:,python:,virtualenv:,system-site-packages,index-url: -- "$@")"
[ ! -v VIRTUAL_ENV ] || die "Activated virtual environment detected. Please deactivate it before running this script."

temp_dir=""
trap cleanup EXIT
trap "exit 1" SIGINT SIGTERM SIGQUIT
temp_dir="$(mktemp -d "/var/tmp/mkdevelvirtualenv.XXXXXX")"

create_virtualenv
