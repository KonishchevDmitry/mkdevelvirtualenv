#!/usr/bin/env bash
#
# Wraps virtualenvwrapper's mkvirtualenv and provides a very easy way of
# creating development virtual environments for your python projects.
#

die() {
    echo "Error:" "$@" >&2
    exit 1
}

show_help() {
    cat <<EOF
usage: $script_name [-h] [-f] [-a PROJECT] [-A PROJECT]... [-n NAME] [-p PYTHON] [-v VIRTUALENV]

Wraps virtualenvwrapper's mkvirtualenv and provides a very easy way of
creating development virtual environments for your python projects.

If you cloned some of required packages into the project root and want to use
the cloned versions instead of installing them via pip into the virtual
environment, just list these package names in local-requirements.txt - they
won't be installed, but their paths will be added to PYTHONPATH of the created
virtual environment.

optional arguments:
  -h, --help            show this help message and exit
  -f, --force           replace existing virtual environment if exists
  -a PROJECT, --project PROJECT
                        path to the project (default is current directory)
  -A PROJECT, --extra-project PROJECT
                        path to an additional project to add to the virtual environment
  -n NAME, --name NAME
                        virtual environment name (default is name of
                        project's directory)
  -p PYTHON, --python PYTHON
                        python interpreter to use (default is python)
  -v VIRTUALENV, --virtualenv VIRTUALENV
                        virtualenv to use (default is virtualenv)
  -s, --system-site-packages
                        give the virtual environment access to the global
                        site-packages
  -i, --index-url URL   base URL of Python Package Index
EOF
}

check_option() {
    [ -n "$2" ] || die "Invalid option $1 value."
}

parse_args() {
    eval set -- "$@"

    while [ $# -gt 0 ]; do
        case "$1" in
            -h|--help) show_help; exit 0;;
            -f|--force) force=1;;
            -a|--project) check_option $1 $2; project_path="$2"; shift;;
            -n|--name) check_option $1 $2; project_name="$2"; shift;;
            -A|--extra-project) check_option $1 $2; extra_project_paths+=("$2"); shift;;
            -p|--python) check_option $1 $2; python="$2"; shift;;
            -v|--virtualenv) check_option $1 $2; virtualenv="$2"; shift;;
            -s|--system-site-packages) virtualenv_options="$virtualenv_options --system-site-packages"; shift;;
            -i|--index-url) check_option $1 $2; pip_options+=("-i" "$2"); shift;;
            --) shift; break;;
            (-*) die "Unrecognized option: $1.";;
            (*) break;;
        esac
        shift
    done

    [ $# -eq 0 ] || die "Invalid parameter: $1."

    project_path="$(cd "$project_path" && pwd)"
    [ "$project_path" != "/" -a "$project_path" != "//" ] || \
        die "Invalid project path: $project_path."

    if [ -z "$project_name" ]; then
        project_name="$(basename "$project_path")"
    else
        [[ "$project_name" != */* ]] || die "Invalid virtual environment name: $project_name."
    fi

    if [[ "$python" != */* ]]; then
        local python_path
        python_path="$(which "$python")" || die "Unable to find '$python' executable."
        python="$python_path"
    fi
}

cleanup() {
    [ -z "$temp_dir" ] || rm -rf "$temp_dir"
}

create_virtualenv() {
    local env_name
    local existing_envs
    local virtualenvwrapper

    if ! type -t mkvirtualenv > /dev/null; then
        if [ "$(uname)" = Darwin ]; then
            virtualenvwrapper="$(which virtualenvwrapper.sh)" || die "Unable to find virtualenvwrapper.sh."
        elif [ -e /etc/bash_completion.d/virtualenvwrapper ]; then
            virtualenvwrapper=/etc/bash_completion.d/virtualenvwrapper
        else
            die "Unable to find virtualenvwrapper."
        fi

        set +eu;
            . "$virtualenvwrapper" || die "Failed to activate virtualenvwrapper.";
        set -eu
    fi

    set +eu;
        existing_envs="$(lsvirtualenv)" || \
            die "Unable to get a list of existing virtual environments.";
    set -eu

    while read env_name; do
        [ "$env_name" = "$project_name" ] || continue
        [ "$force" -ne 0 ] || die "Virtual environment '$project_name' already exists."

        set +eu
            rmvirtualenv "$project_name" || die "Failed to remove virtual environment '$project_name'."
        set -eu
    done <<<"$existing_envs"

    set +eu
        VIRTUALENVWRAPPER_VIRTUALENV="$virtualenv" VIRTUALENVWRAPPER_VIRTUALENV_ARGS="$virtualenv_options" \
            mkvirtualenv -p "$python" -a "$project_path" "$project_name" && \
                workon "$project_name" || die "Failed to create the virtual environment."
    set -eu

    configure_virtualenv
}

configure_virtualenv() {
    set +u
        pip install "${pip_options[@]}" -U pip
    set -u

    local extra_project_path
    local extra_project_name
    local locally_provided_requirements=""

    if [ ${#extra_project_paths[@]} -ne 0 ]; then
        # Collecting a list of requirements provided by extra projects
        for extra_project_path in "${extra_project_paths[@]}"; do
            if [ -e "$extra_project_path/setup.py" ]; then
                extra_project_name="$(cd "$extra_project_path" && "$python" setup.py --name)"
                locally_provided_requirements="$locally_provided_requirements $extra_project_name"
            fi
        done

        # The main project may override requirements, so configure the extra projects first
        for extra_project_path in "${extra_project_paths[@]}"; do
            configure_project "$extra_project_path" "$locally_provided_requirements"
        done
    fi

    configure_project "$project_path" "$locally_provided_requirements"
}

configure_project() {
    local sed
    local project_path
    local package_name
    local package_path
    local local_packages
    local requirements_path
    local locally_provided_requirements

    project_path="$1"
    locally_provided_requirements="$2"

    [ "$(uname)" = Darwin ] && sed='sed -E' || sed='sed -r'

    echo "Configuring $project_path project..."

    rm -f "$temp_dir"/*requirements.txt

    for requirements_path in requirements.txt dev-requirements.txt test-requirements.txt; do
        [ ! -e "$project_path/$requirements_path" ] || \
            cp "$project_path/$requirements_path" "$temp_dir/project-$requirements_path"
    done

    if [ -e "$project_path/local-requirements.txt" ]; then
        local_packages="$(< "$project_path/local-requirements.txt")"

        for package_name in $local_packages; do
            package_path="$project_path/$package_name"

            [ -d "$package_path" ] || \
                die "Unable to find local package '$package_name' which is listed in $project_path/local-requirements.txt."

            if [ -d "$package_path/src" ]; then
                add2virtualenv "$package_path/src"
            else
                add2virtualenv "$package_path"
            fi

            [ ! -e "$package_path/requirements.txt" ] || \
                cp "$package_path/requirements.txt" "$temp_dir/package-$package_name-requirements.txt"
        done

        locally_provided_requirements="$locally_provided_requirements $local_packages"
    fi

    shopt -s nullglob
        for package_name in $locally_provided_requirements; do
            for requirements_path in "$temp_dir/"*requirements.txt; do
                $sed -i.bak "/^\\s*${package_name/./\\.}([<=>]|\\s*\$)/d" "$requirements_path"
            done
        done

        # The project may override requirements, so install its requirements at the very end
        for requirements_path in "$temp_dir/"package-*-requirements.txt "$temp_dir/"project-*requirements.txt; do
            set +u
                pip install "${pip_options[@]}" -r "$requirements_path"
            set -u
        done
    shopt -u nullglob

    add2virtualenv "$project_path"
}

set -eu
script_name="$0"

force=0
project_path="$PWD"
project_name=""
extra_project_paths=()
python="python"
virtualenv="virtualenv"
virtualenv_options=""
pip_options=()

parse_args "$(getopt -n "$0" -o hfa:n:A:p:v:si: -l help,force,project:,name:,extra-project:,python:,virtualenv:,system-site-packages,index-url: -- "$@")"
[ ! -v VIRTUAL_ENV ] || die "Activated virtual environment detected. Please deactivate it before running this script."

temp_dir=""
trap cleanup EXIT
trap "exit 1" SIGINT SIGTERM SIGQUIT
temp_dir="$(mktemp -d "/var/tmp/mkdevelvirtualenv.XXXXXX")"

create_virtualenv